# mcloc
A lines-of-code counter.

Focused on C++ projects, which sometimes include code generated
by bison, flex, moc, rcc and uic.

Has support for many other languages, but since I'm not a user of many
of them, may be inaccurate on other languages.  If you use this code,
feel free to open an issue if you find problems.

## Distinguishing feature: ignore typical generated code by default
When I first wrote mcloc more than 20 years ago, I needed a tool that
could ignore source code that was generated by flex or bison.  By
default, mcloc will ignore code generated by flex, bison, moc, rcc and
uic and instead just count the generator input.  That's my personal
preference; generated code is not code I maintain, and is usually much
larger than the generator input I maintain (and hence misleading).
Counters for generated code can be enabled on the command line if
desired.

## Reasonably fast
Speed has never been an issue in my usage.  As an example,
on a large code base which is orders of magnitude larger than my
typical use:

```
% time mcloc -l -Lc++ ~/gits/qt5
         CODE    COMMENTS LANGUAGE                                             
L  12,892,785   2,270,945 C++                                                  
   12,892,785   2,270,945 TOTAL  (208.4ms, 72.77M lines/s, 308% sys 1,361% usr)
3.231u 1.117s 0:01.07 405.6%    0+0k 0+0io 0pf+0w
```

I don't need it to be any faster.  Note that above we see it only took
208.4 milliseconds to count lines in the source.  The remaining 800
milliseconds or so was spent doing things like reading the configuration,
finding files of interest in the filesystem, etc.  For my typical usage,
on MUCH smaller code bases, it's essentially instantaneous.  And I'm not
willing to gravely risk accuracy in the name of speed.  A few lines here
and there, no big deal.  But any time I find it getting lost and grossly
miscounting, I fix it.  This tends to be a problem with most LOC counters
and it's understandable.  There are limitations with what can be done
accurately for some languages without writing a full language front end.
And some sources (the patterns in the rules of flex source, for example)
tend to throw a wrench in the mechanisms used by other tools.

## Limitations

Like all LOC counters that don't implement a full language front end,
it is not always 100% accurate.  But in the areas that are important
to me in my own code (C, C++, flex, bison), it's more accurate than
other tools I've tried.  Your mileage may vary.  If you find a test
case where it gets lost, open an issue and I'll try to fix it (and
create a unit test so it doesn't happen again).

Mapping a file to a scanner is done via filename extensions (or
regular expressions for a few cases).  This is by design and it's
highly unlikely I'll change it; all of my projects follow consistent
naming conventions and my work is focused on languages where source
files all have common extensions.  The mappings can be configured in
the configuration file.  This is a design tradeoff that allows
me to ignore files that don't match a naming convention instead
of opening them and trying to figure out what they are.

Of course this makes it unsuitable for some code bases, especially
those that might have conflicting extensions (say perl and Prolog)
and definitely those that have no filename extensions.
