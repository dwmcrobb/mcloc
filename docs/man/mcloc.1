.de hL
\fI\ \ \\$1\l'|2\(ul'\fR
..
.de bL
\fI\\$1\ \\$2\l'|2\(ul'\fR
..
.AM
.Dd Jan 18, 2020
.Dt mcloc 1
.Os mcplex.net
.Sh NAME
.Nm mcloc
.Nd count lines of code in source files
.Sh SYNOPSIS
.Nm
.Op Fl C
.Op Fl c Ar config
.Op Fl E Ar extension(s)
.Op Fl L Ar language(s)
.Op Fl S Ar scanner(s)
.Op Fl d | e | l | s
.Op Fl g
.Op Fl j Ar numThreads
.Op Fl M Ar cocomo_config
.Op Fl m
.Op Fl o
.Op Fl q
.Op Fl a | r
.Cm path(s)
.Sh DESCRIPTION
.Xr \fBmcloc 1\fR
is a simple command line utility for obtaining a reasonably accurate
count of lines of code and comments in Ada, Assembly, awk,
bison, C, C++, C#, Clojure, Cmake, CSS, D, Dart, Erlang,
Bflex, Fortran, Go, Groovy, Haskell, HTML, IDL, java, JSON,
Julia, Kotlin, Lisp, Lua, m4, make, man, Objective-C, Perl, PHP,
Prolog, protobuf, Python, QML, R, Ruby, Rust, Scala, Scheme, sed, SQL,
Swift, TeX/LaTeX, TOML, TypeScript, YAML and shell script source
files.
.Pp
The count is not always 100% accurate.  For 100% accuracy, we'd have
to fully parse the source code, which is a non-trivial activity
for the languages I am most interested in (C++, for example).  The
point of
.Xr \fBmcloc 1\fR
is quick assessments of source code size, mainly to give a developer a
sense of the effort required to maintain a set of source code files.
It's particularly useful in refactoring efforts, where reduction of
source code size may be a stated objective.
.Ss Optional arguments
The following optional command line arguments are available:
.Pp
.Bl -tag -width indent
.It Fl C
Print the configuration and exit (do not scan files).  Note this will
incorporate any changes made with the \fI-E\fR and \fI-S\fR arguments.
.It Fl c Ar config
Use \fIconfig\fR as the configuration file instead of the default
configuration file.
.It Fl E Ar extension(s)
Only scan files with an extension specified in \fIextensions(s)\fR,
which is a comma-separated list of file extensions
(e.g. \fI.lex,.c,.h\fR).
.It Fl L Ar language(s)
Only scan files for the languages specified in \fIlanguage(s)\fR,
which is a comma-separated list of languages (e.g. \fIc++,python\fR).
.It Fl S Ar scanners(s)
Only activate the scanners named in the comma-separated list of
\fIscanners\fR, from the following list:
.Pp
Ada, CSS, Clojure, Cpp, D, Erlang, Flex, Fortran, Haskell, HTML, Julia,
Kotlin, Lisp, Lua, m4, Manpage, NoComments, Perl, Prolog, Python, Ruby,
Rust, Shell, SQL, TeX
.It Fl a
Sort output entries by lines of code, in ascending order.
.It Fl d
Print counters for each directory (do not show files).
.It Fl e
Print counters for each file extension instead of counters for each source
file and/or directory.
.It Fl l
Print counters for each language instead of counters for each source file
and/or directory.
.It Fl s
Print counters for each scanner instead of counters for each source file
and/or directory.
.It Fl g
Include files generated by bison, flex, moc, rcc or uic.
.It Fl j Ar numThreads
Specify the number of threads to use to parse source files.  Note there
are tradeoffs here, and more threads may or may not be faster than fewer
threads.
.Pp
The default thread count for parsing source files is the concurrency
reported by std::thread::hardware_concurrency().
.It Fl M Ar cocomo_config
Use \fIcocomo_config\fR as the COCOMO project configuration file.
.It Fl m
Report COCOMO Intermediate estimates.
.It Fl o
Do not recurse into subdirectories.
.It Fl q
Only print totals (quiet).
.It Fl r
Sort output entries by lines of code, in descending order.
.El
.Ss Required argument(s)
.Xr \fBmcloc 1\fR requires one or more \fBpath(s)\fR after the optional
arguments.  Each of these arguments must be a path to a file or directory.
.Ss Output
The output of
.Xr \fBmcloc 1\fR
has 4 columns.  In the first line (column titles) and the last line
(TOTAL), the first column is intentially left blank to make it easy
to grep for only data lines in the output.  For all other lines in the
output, the first column contains a single-character indicator of the
type of the row:
.Pp
.Bl -tag -width "D" -compact -offset indent
.It D
directory
.It F
file
.It G
generated file
.It E
filename extension
.It L
language
.It S
scanner
.El
.Pp
The second column of a data row contains the lines of code counter.
.Pp
The third column of a data row contains the comment counter.
.Pp
The fourth column contains the row's label.  This may be a path to
a directory, a filename, a file extension, a language, a scanner, or
\fBTOTAL\fR.
.Pp
See
.Sx EXAMPLES
for example output.
.Sh ENVIRONMENT
The \fIMCLOC\fR environment variable can be used to set default options.
For example, a value of 'a:l' would enable ascending sort ('-a') and
print-by-language ('l') options.  A value of 'a:l:L=c++,c' would do the
same and also only select C and C++ files for counting.  Command line
arguments override the settings in \fIMCLOC\fR environment variable.
.Sh NOTES

The main goal of
.Xr \fBmcloc 1\fR
is fast, reasonably accurate counting of lines of code and comments in
source files.  I primarily use it on C and C++ projects (Which may
include flex, bison, and Qt moc/uic/rcc files).  I can't really vouch
for the accuracy of counts for other languages simply because I
haven't used
.Xr \fBmcloc 1\fR for any significant code bases in other languages.
.Pp
.Xr \fBmcloc 1\fR
occupies an area somewhere closer to high speed than complete accuracy,
by design.  For my personal source code style, I've found it to produce
reliable lines-of-code metrics, and it's always done so at a rate that
makes me happy to use it.  Your mileage may vary, as I wrote this tool
for my own use.
.Pp
Below is a table showing lines/second while processing C++ on a few
machines in my home.
.Pp
.TS
box tab(:);
lb|lb|lb|lb
l|l|l|r.
CPU:I/O:O/S:lines/sec
_
Threadripper 3960X:NVMe (PCI 4 x4):Ubuntu 20.04:75,000,000+
Core i9 2.9GHz:NVMe (PCI 3 x4):MacOS Mojave:14,000,000+
E3-1270 V2 3.50GHz:SATA SSD:FreeBSD 12.2:20,000,000+
2x Xeon L5640 2.27GHz:SATA SSD:FreeBSD 12.2:25,000,000+
Core i5 2405S 2.50GHz:SATA SSD:FreeBSD 12.2:10,000,000+
ARM Cortex-A72 1.5GHz:microSD:Raspbian 10:600,000 
.TE
.br
\X'ps:'\c
.br
.Pp
I find these numbers sufficient for my own use.  Much of the time I'm
looking at a smaller code base or a smaller piece of a larger code
base.  Usually less than 200,000 lines of code.
.Pp
.Sh EXAMPLES
Note that \fBmcloc\fR will use locale formatting for line counts.
Some of the examples below show output for the C locale, while others
shouw output for en_US.UTF-8.

An example from the classes/src directory of
.Xr \fBmcloc 1\fR
itself:
.Pp
.Bd -literal -offset 0
% mcloc *Config*
.hL "    CODE COMMENTS PATH                                               "
D      560      220 .
F      260      138   DwmMclocConfig.cc
F       50       39   DwmMclocConfigLex.lex
.bL "F" "     250       43   DwmMclocConfigParse.y                             "
\fB\ \ \ \ \ \ \ 560      220 TOTAL\fR  (1.129ms, 690.9K lines/s, 0% sys 434% usr)
.Ed
.Pp
What if I include generated source files and sort by size?  Note how
in this case, the generated code (which we never modify) is much more
code than what we actually maintain.  This is a case where it's
clearly misleading to include generated code in a lines-of-code
metric.
.Pp
.Bd -literal -offset 0
% mcloc -a -g *Config*
.hL "    CODE COMMENTS PATH                                               "
D     3638      905 .
F       50       39   DwmMclocConfigLex.lex
G       56       33   DwmMclocConfigParse.hh (DwmMclocConfigParse.y)
F      250       43   DwmMclocConfigParse.y                              
F      260      138   DwmMclocConfig.cc
G     1451      411   DwmMclocConfigLex.cc (DwmMclocConfigLex.lex)
G     1571      241   DwmMclocConfigParse.cc (DwmMclocConfigParse.y)
\fB\ \ \ \ \ \ 3638      905 TOTAL\fR  ( 887us, 5.122M lines/s, 0% sys 394% usr)
.Ed
.Pp
What about per file extension, sorted by lines of code?
.Pp
.Bd -literal -offset 0
% mcloc -ae .
.hL "       CODE    COMMENTS EXTENSION/EXPRESSION                             "
E          79           2 "Makefile"
E         398         109 .y
E        1398         601 .cc
.bL "E" "       1408        1246 .lex                                                 "
\fB\ \ \ \ \ \ \ \ \ 3283        1958 TOTAL\fR  (4.426ms, 1.184M lines/s, 126% sys 642% usr)
.Ed
.Pp
How many lines of code per language in libDwm, sorted by lines of code?
.Pp
.Bd -literal -offset 0
% mcloc -al libDwm/trunk
.hL "       CODE    COMMENTS LANGUAGE                                         "
L         217           8 CSS
L         323           0 man
L         439         111 Shell
L         593          19 Make
L         698          58 m4
L         880         308 flex
L       1,061         102 bison
.bL "L" "     34,307      22,730 C++                                              "
\fB\ \ \ \ \ \ \ 38,518      23,336 TOTAL\fR  (9.65ms, 6.41M lines/s, 219% sys 141% usr)
.Ed
.Pp
How many lines of code per language in qt5?  Note this is a bit misleading
since Qt uses '.h' for C++ header files, and hence we count many of Qt's
header files as C instead of C++.
.Pp
.Bd -literal -offset 0
% mcloc -a -l ~/gits/qt5
.hL "     CODE    COMMENTS LANGUAGE                                         "
L        52           3 SQL
L        87          25 sed
L       183          55 awk
L       222          51 Scheme
L       351          58 Swift
L       662         275 Ruby
L       884         282 YAML
L       929         175 Dart
L      1042         124 TeX
L      1116          47 D
L      7887        2804 Make
L      7973         663 Lua
L      8648        8330 PHP
L      8998           6 QtRc
L     10371         843 bison
L     13943        2514 Go
L     27503        5446 Cmake
L     29944       47914 IDL
L     40095         466 man
L     41457       19496 protobuf
L     42749         524 Lisp
L     53406       18938 Shell
L     54689        5720 CSS
L     57084         407 flex
L     57954       13193 C#
L     64504        2531 m4
L     71597          27 QtUi
L     84993       14855 Perl
L    129891       43134 Java
L    232899       42446 Objective-C
L    242735       19706 Assembly
L    335257      189304 QML
L    475669      187102 Python
L    488130        2039 TypeScript
L    531711       13136 HTML
L    765125           0 JSON
L    822643        9663 XML
L   1188976      943066 JavaScript
L   7853913     2566652 C
.bL "L" " 12892785     2270945 C++                                                  "
\fB\ \ \ 26649057     6432965 TOTAL\fR  (1.257s, 26.32M lines/s, 265% sys 586% usr)
.Ed
.Pp
We can get an idea of the naming conventions for Qt C and C++ header files
by listing by file extension and selecting particular file extensions:
.Bd -literal -offset 0
% mcloc -E.c,.cc,.cpp,.cxx,.h,.hh,.hxx -a -e ~/gits/qt5
.hL "      CODE    COMMENTS DIR                                             "
E       1293        1393 .hxx
E      33028        2207 .cxx
E      54910       14204 .hh
E    3428463      768742 .c
E    4378933     1942584 .h
E    5210036     1312353 .cpp
.bL "E" "   7091067      947043 .cc                                                  "
\fB\ \ \ \ 20197730     4988526 TOTAL\fR  (350.5ms, 71.86M lines/s, 414% sys 1165% usr)
.Ed
.Pp
How many lines of code in each directory in libDwm?
.Pp
.Bd -literal -offset 0
% mcloc -d libDwm/trunk
.hL "      CODE    COMMENTS DIR                                             "
D      1,191         169 libDwm/trunk/
D         16           0 libDwm/trunk/apps
D        112          44 libDwm/trunk/apps/dwmnet
D        121          60 libDwm/trunk/apps/dwmspath
D        256          56 libDwm/trunk/apps/dwmwhat
D        191          51 libDwm/trunk/apps/fbsddeps
D         47          43 libDwm/trunk/apps/fixcflags
D        276          54 libDwm/trunk/apps/mcping
D        537         111 libDwm/trunk/apps/mkfbsdmnfst
D        139          50 libDwm/trunk/apps/psg
D        239           8 libDwm/trunk/doc
D        176          13 libDwm/trunk/doc/examples
D      8,342      11,515 libDwm/trunk/include
D         12           0 libDwm/trunk/packaging
D     16,486       6,996 libDwm/trunk/src
.bL "D" "    10,377       4,166 /Users/dwm/svn/dwm/libDwm/trunk/tests      "
\fB\ \ \ \ \ \ 38,518      23,336 TOTAL\fR  (2.65ms, 23.4M lines/s, 455% sys 450% usr)
.Ed
.Sh FILES
.Pa /usr/local/etc/mcloc.cfg
is the global configuration file.
.Pp
.Pa ${HOME}/.mcloc
will be used instead of the global configuration file, if present.
.Pp
.Pa /usr/local/etc/mcloc_cocomo1_imtermediate.cfg
is the default COCOMO project configruation file.
.Sh SEE ALSO
.Xr \fBawk 1\fR ,
.Xr \fBbison 1\fR ,
.Xr \fBflex 1\fR ,
.Xr \fBperlsyn 1\fR ,
.Xr \fBsed 1\fR
.Sh HISTORY
I first wrote
.Xr \fBmcloc 1\fR
in 1998.  At the time, we didn't have a lot of tools to count lines of
C++ code, and none of them could count generator files (flex and bison
input) while ignoring generated files (flex and bison output).
.Xr \fBmcloc 1\fR
was born when I needed to keep track of my progress on various
flex/bison lexers/parsers (SMIv2 MIB compiler, BGP route log parser,
etc.).  It's fairly typical for flex and bison output to be two
decimal orders of magnitude larger than the input, but we don't
maintain the output, we maintain the input.  I needed something quick
and dirty to recognize generated files and not include them in my LOC
metrics (unless requested).
.Pp
.Xr \fBmcloc 1\fR
was updated with relatively minor tweaks throughout the 2000's and
2010's.
.Pp
In 2019 and early 2020, I rewrote
.Xr \fBmcloc 1\fR
to use reentrant lexical analyzers and allow multiple threads (15
years overdue!).  I also restructured to use a two-level storage
scheme (directories and files within a directory) and
std::unordered_map.  The original std::map based implementation wasn't
terribly slow, but the way I used it (full paths as keys) meant longer
keys versus the two-level scheme and also hindered fast calculation of
LOC per directory.
.Pp
Since I'm now using std::filesystem instead of
.Xr \fBfts 3\fR ,
the code should be portable to Windows with a getopt() replacement
(I haven't tried yet).
.Pp
I also added the ability to show lines of code and comments per file
extension or per type, as well as the ability to sort by size.  In
addition, I added smarter code to recognize source code generated by
\fBflex(1)\fR or \fBbison(1)\fR; the current version recognizes
comments and preprocessor directives in the generated code instead of
relying on matching filenames.  The same is true for code generated
by Qt tools (moc, rcc, uic).  This allows me to ignore generated
files even if I can't find the generator source code in the given
directories, and doesn't require parsing flex and bison options in the
generator sources nor peeking at build infrastructure.  However,
\fBflex(1)\fR and \fBbison(1)\fR don't produce anything in their
output to indicate the source of the generated code if you disable
\fB#line\fR directives.  If you use the \fB-L\fR option of
\fBflex(1)\fR or the \fB-l\fR option of \fBbison(1)\fR, for example,
.Xr \fBmcloc 1\fR
will still recognize the generated code as generated, but will not be
able to name the source.
.Sh BUGS
.Xr \fBmcloc 1\fR
is driven primarily by filename extensions, by design.  That makes it
more suitable for code bases that have common source file naming conventions,
and unsuitable for code bases where files can't be easily identified
by file extension or simple regular expression matching.
.Pp
Prolog is disabled in the default configuration due to file extension
conflicts with Perl (.pl) and Qt project files ('.pro').
.Pp
The grouping of languages under scanners isn't particularly useful to
the end user.  It's an implementation detail which allows languages
with the same comment syntax to be handled by a single scanner.
.Sh AUTHORS
Daniel W. McRobb
.Mt dwm@mcplex.net
.\" I need to document the configuration!!!!
